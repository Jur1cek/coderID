<?
//<meta http-equiv="content-type" content="text/html; charset=utf-8">
?>
<h2>Proper Shuffle</h2>
<p>&nbsp;</p>
<h3>Problem</h3>
<p>A <em>permutation</em> of size <strong>N</strong> is a sequence of <strong>N</strong> numbers, each between 0 and <strong>N</strong>-1, where each number appears exactly once. They may appear in any order.</p>
<p>There are many (<strong>N</strong> <em>factorial</em>, to be precise, but it doesn't matter in this problem) permutations of size <strong>N</strong>. Sometimes we just want to pick one at random, and of course we want to pick one at random <em>uniformly</em>: each permutation of size <strong>N</strong> should have the same probability of being chosen.</p>
<p>Here's the pseudocode for one of the possible algorithms to achieve that goal (we'll call it the <em>good</em> algorithm below):</p>
<pre>for <strong>k</strong> in 0 .. <strong>N</strong>-1:    <strong>a</strong>[<strong>k</strong>] = <strong>k</strong>  for <strong>k</strong> in 0 .. <strong>N</strong>-1:    <strong>p</strong> = randint(<strong>k</strong> .. <strong>N</strong>-1)    swap(a[<strong>k</strong>], a[<strong>p</strong>])</pre>
<p>In the above code, randint(<strong>a</strong> .. <strong>b</strong>) returns a uniform random integer between <strong>a</strong> and <strong>b</strong>, inclusive.</p>
<p>Here's the same algorithm in words. We start with the <em>identity</em> permutation: all numbers from 0 to <strong>N</strong>-1 written in increasing order. Then, for each <strong>k</strong> between 0 and <strong>N</strong>-1, inclusive, we pick an independent uniform random integer <strong>p</strong><strong>k</strong> between <strong>k</strong> and <strong>N</strong>-1, inclusive, and swap the element at position <strong>k</strong> (0-based) in our permutation with the element at position<strong>p</strong><strong>k</strong>.</p>
<p>Here's an example for <strong>N</strong>=4. We start with the identity permutation:</p>
<p>0 1 2 3</p>
<p>Now <strong>k</strong>=0, and we pick a random <strong>p</strong>0 between 0 and 3, inclusive. Let's say we picked 2. We swap the 0th and 2nd elements, and our permutation becomes:</p>
<p>2 1 0 3</p>
<p>Now <strong>k</strong>=1, and we pick a random <strong>p</strong>1 between 1 and 3, inclusive. Let's say we picked 2 again. We swap the 1st and 2nd elements, and our permutation becomes:</p>
<p>2 0 1 3</p>
<p>Now <strong>k</strong>=2, and we pick a random <strong>p</strong>2 between 2 and 3, inclusive. Let's say we picked 3. We swap the 2nd and 3rd elements, and our permutation becomes:</p>
<p>2 0 3 1</p>
<p>Now <strong>k</strong>=3, and we pick a random <strong>p</strong>3 between 3 and 3, inclusive. The only choice is 3. We swap the 3rd and 3rd elements, which means that the permutation doesn't change:</p>
<p>2 0 3 1</p>
<p>The process ends now, and this is our random permutation.</p>
<p>There are many other algorithms that produce a random permutation uniformly. However, there are also many algorithms to generate a random permutation that look very similar to this algorithm, but are not uniform — some permutations are more likely to be produced by those algorithms than others.</p>
<p>Here's one bad algorithm of this type. Take the <em>good</em> algorithm above, but at each step, instead of picking <strong>p</strong><strong>k</strong> randomly between <strong>k</strong> and <strong>N</strong>-1, inclusive, let's pick it randomly between 0 and <strong>N</strong>-1, inclusive. This is such a small change, but now some permutations are more likely to appear than others!</p>
<p>Here's the pseudocode for this algorithm (we'll call it the <em>bad</em> algorithm below):</p>
<pre>for <strong>k</strong> in 0 .. <strong>N</strong>-1:    <strong>a</strong>[<strong>k</strong>] = <strong>k</strong>  for <strong>k</strong> in 0 .. <strong>N</strong>-1:    <strong>p</strong> = randint(0 .. <strong>N</strong>-1)    swap(a[<strong>k</strong>], a[<strong>p</strong>])</pre>
<p>In each test case, you will be given a permutation that was generated in the following way: first, we choose either the good or the bad algorithm described above, each with probability 50%. Then, we generate a permutation using the chosen algorithm. Can you guess which algorithm was chosen just by looking at the permutation?</p>
<h3>Solving this problem</h3>
<p>This problem is a bit unusual for Code Jam. You will be given <strong>T</strong> = 120 permutations of<strong>N</strong> = 1000 numbers each, and should print an answer for each permutation – this part is as usual. However, you don't need to get all of the answers correct! Your solution will be considered correct if your answers for at least <strong>G</strong> = 109 cases are correct. However, you must follow the output format, even for cases in which your answer doesn't turn out to be correct. The <em>only</em> thing that can be wrong on any case, yet still allow you to be judged correct, is swapping GOOD for BAD or vice versa; but you should still print either GOOD or BAD for each case.</p>
<p>It is guaranteed that the permutations given to you were generated according to the method above, and that they were generated independently of each other.</p>
<p>This problem involves randomness, and thus it might happen that even the best possible solution doesn't make 109 correct guesses for a certain input, as both the good and the bad algorithms can generate any permutation. Because of that, this problem doesn't have a Large input, and has just the Small input which you can try again if you think you got unlucky. Note that there is the usual 4-minute penalty for incorrect submissions if you later solve that input, even if the only reason you got it wrong was chance.</p>
<p>In our experience with this problem, that <em>did happen</em> (getting wrong answer just because of chance); so if you are confident that your solution should be working, but it failed, it might be a reasonable strategy to try again with the same solution which failed.</p>
<p>Good luck!</p>
<h3>Input</h3>
<p>The first line of the input gives the number of test cases, <strong>T</strong> (which will always be 120). Each test case contains two lines: the first line contains the single integer <strong>N</strong> (which will always be 1000), and the next line contains <strong>N</strong> space-separated integers - the permutation that was generated using one of the two algorithms.</p>
<h3>Output</h3>
<p>For each test case, output one line containing &quot;Case #<strong>x</strong>: <strong>y</strong>&quot;, where <strong>x</strong> is the test case number (starting from 1) and <strong>y</strong> is either &quot;GOOD&quot; or &quot;BAD&quot; (without the quotes). You should output &quot;GOOD&quot; if you guess that the permutation was generated by the first algorithm described in the problem statement, and &quot;BAD&quot; if you guess that the permutation was generated by the second algorithm described in the problem statement.</p>
<h3>Limits</h3>
<p><strong>T</strong> = 120<br />
  <strong>G</strong> = 109<br />
  <strong>N</strong> = 1000<br />
  Each number in the permutation will be between 0 and <strong>N</strong>-1 (inclusive), and each number from 0 to <strong>N</strong>-1 will appear exactly once in the permutation.</p>
<h3>Sample</h3>
<div>
  <table>
    <tbody>
      <tr>
        <td><br />
          Input <br />
        </td>
        <td><br />
          Output <br />
        </td>
      </tr>
      <tr>
        <td><pre>2
3
0 1 2
3
2 0 1
</pre></td>
        <td><pre>Case #1: BAD
Case #2: GOOD</pre></td>
      </tr>
    </tbody>
  </table>
</div>
<h3>Note</h3>
The sample input doesn't follow the limitations from the problem statement - the real input will be much bigger.
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<h3>Answer</h3>
<form id="form1" name="form1" enctype="multipart/form-data" method="post" action="<?=$_SERVER['PHP_SELF']?>">
  <input name="userfile" type="file" />
  <input type="submit" name="button" id="button" value="전송" />
</form>
<?
$info = pathinfo($_SERVER['PHP_SELF']);
$qid = $info['filename'];

$in_file_path = "q/{$qid}.in.txt";
$out_file_path = "q/{$qid}.out.txt";

$in_contents = "";
$out_contents = "";
if ( $_FILES ) {
	if (!move_uploaded_file($_FILES['userfile']['tmp_name'], $in_file_path)) die("move_uploaded_file error");
	$in_contents = file_get_contents($in_file_path);
	$in_contents = str_replace("\r", "", $in_contents);
} else if ( file_exists($in_file_path) ) {
	$in_contents = file_get_contents($in_file_path);
	$in_contents = str_replace("\r", "", $in_contents);
} else {
	exit;
}
$in_array = explode("\n", $in_contents);
$out_array = array();


/* begin */	
$line_cnt = 0;
$sample_cnt = intval($in_array[$line_cnt++]);

$sample_array = array();
for ( $sample_idx = 0 ; $sample_idx < $sample_cnt ; $sample_idx++ ) {

	
	$sample = array();
	$sample['cnt'] = $in_array[$line_cnt++];
	$sample['n_array'] = explode(" ", $in_array[$line_cnt++]);

	$sample_array[] = $sample;
}

for ( $sample_idx = 0 ; $sample_idx < count($sample_array) ; $sample_idx++ ) {
	
	$sample = $sample_array[$sample_idx];
	$sample_cnt = count($sample['n_array']) ;
	
	$n_list = array();
	for ( $i = 0 ; $i < $sample_cnt ; $i++ ) {
		$n_list[$i] = $sample['n_array'][$i];
	}
	
	$t = 0;
	$f = 0;	
	for ( $i = 0 ; $i < $sample_cnt ; $i++ ) {
		if ( $i < $sample_cnt/2 ) {
			if ( $n_list[$i] < $sample_cnt/2 ) $t++;
			else $f++;
		} else {
			if ( $n_list[$i] > $sample_cnt/2 ) $t++;
			else $f++;
		} 
	}
	
	if ( $t > 1.05*$f ) {
		$out_array[] = sprintf("Case #%d: BAD", $sample_idx+1);
	} else {
		$out_array[] = sprintf("Case #%d: GOOD", $sample_idx+1);
	}
}


/* end */	
$out_contents = implode("\n", $out_array);
file_put_contents($out_file_path, $out_contents);

echo "
<table border=0 width=100%>
  <tr>
    <td valign='top'><a href='{$in_file_path}'>{$in_file_path}</a></td>
    <td valign='top'><a href='{$out_file_path}'>{$out_file_path}</a></td>
  </tr>
  <tr>
    <td valign='top'><pre>{$in_contents}</pre></td>
    <td valign='top'><pre>{$out_contents}</pre></td>
  </tr>
</table>
";

